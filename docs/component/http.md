## HTTP 请求方法

:::details 点击查看

![请求方法](/http/method.png)

:::

---

## HTTP 状态码

- **1XX 信息**

  服务器接受到请求，需要请求者继续操作。（实际开发很少遇到）

- **2XX 成功**

  `200` 请求成功。一般用于 GET 、 POST 请求。

  `201` 成功请求并创建新的资源。一般用于 GET 、 POST 请求。

  `204` 与 200 基本相同，但响应头后没有 body 数据。

  `206` 是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的
  部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是
  资源的全部，而是其中的一部分。

  :::details 查看详解

  ![2xx](/http/2xx.png)

  :::

- **3XX 重定向**

  `301` 永久重定向。

  `302` 临时重定向。

  `304` 重定向到已缓存的文件。

  :::details 查看详解

  ![3xx](/http/3xx.png)

  :::

- **4XX 客户端错误**

  `400` 请求报文有错误，但具体是数据格式错误、缺少请求头还 是 URI 超长它没有明确
  说，只是一个笼统的错误。

  `401` 当前请求需要用户验证。

  `403` 服务器禁止访问资源。

  `404` 资源在本服务器上未找到，所以无法提供给客户端。

  `408` 请求超时。

  :::details 查看详解

  ![4xx](/http/4xx.png)

  :::

- **5XX 服务器错误**

  `500` 服务器内部错误。

  `501` 服务器不支持该请求方法。

  `502` 通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问
  后端服务器时发生了错误.

  `503` 服务器繁忙。

  :::details 查看详解

  ![5xx](/http/5xx.png)

  :::

---

## 浏览器跨域

存在跨域是为了保证用户的隐私和数据安全，跨域问题是因为浏览器的同源策略，如果不同
源即跨域。跨域本质上是后端解决，但是在开发环境下可以配置反向代理来解决跨域，对于
那些第三方的接口，可以使用 jsonp 的形式解决跨域。

**同源策略：** 浏览器不能去请求**协议**、**域名**、**端口**任何一个不相同的服务
器资源。比如：

> 1.  无法读取非同源网页的 Cookie、LocalStorage、IndexedDB
> 2.  无法接触非同源网页的 DOM
> 3.  无法向非同源地址发送 Ajax 请求（可以发送，但响应数据会被浏览器的同源策略拦
>     截）

### 如何解决跨域问题？

1. **反向代理**

   ::: tip 反向代理

   把目标服务器的请求代理到自己的服务器中，这样就实现了在自己的服务器中去请求自
   己的接口资源，自然就不存在跨域问题了。

   在生产环境中也可以配置 nginx 的反向代理来解决跨域问题。

   :::

   ::: details 查看代码

   ```js
   // vue.config.js
   module.exports = {
     devServer: {
       // 配置反向代理
       proxy: {
         "/api": {
           // 以/api开头的请求
           target: "https://xxx.com", // 以/api开头的请求，全部代理到https://xxx.com上
           // ws: true,
           changeOrigin: true,
         },
       },
     },
   };
   ```

   :::

2. **服务的响应报文包含了正确 CORS 响应头**

   如果服务的响应报文包含了正确 CORS 响应头，那么前后的通讯就不再存在跨域问题，
   可以理解为在后台服务中开启了白名单。所以本质上来讲，解决跨域问题还是需要后端
   处理。

   ```
   // 该资源可以被任意外域访问
    Access-Control-Allow-Origin: *

   // 服务端仅允许来自http://xxx.com的访问
    Access-Control-Allow-Origin: http://xxx.com
   ```

3. **JSONP**

   > 浏览器的同源策略对 JavaScript 脚本向不同域的服务器请求数据进行了限制，但是
   > 没有对 HTML 中的`<script>`标签进行限制，我们可以基于此规则，动态创
   > 建`<script>`标签进行跨域资源访问。
   >
   > `<script>`标签中 src 这一属性值设置为：接口地址+处理数据的回调函数名称。

   :::details 查看代码

   ```js
   var script = document.createElement("script");
   script.type = "text/javascript";
   // 设置接口地址+数据获取成功后的回调函数（handleData）
   script.src = "http://xxx.com/api/list&callback=handleData"; // 通常为后端提供的接口
   document.body.appendChild(script);
   // 回调执行函数
   function handleData(res) {
     data = JSON.stringify(res);
     console.log(data);
   }
   ```

   > 注意：因为请求数据的接口地址是写在了`<script>`标签中 src 这一属性值里面，那
   > 么数据请求的方式就只能支持 GET 请求，其他请求无法实现。目前常用于解决请求第
   > 三方服务，比如解决调用百度地图 API 的跨域问题。

   :::

---

## cookies、sessionStorage、localStorage 的区别

| 特点         | cookie                                                       | sessionStorage          | localStorage                 |
| ------------ | ------------------------------------------------------------ | ----------------------- | ---------------------------- |
| 数据生命周期 | 可以指定 maxAge 的值规定 cookie 失效时间，默认关闭浏览器失效 | 关闭浏览器/关闭网站失效 | 除非数据被清理，否则一直存在 |
| 存放数据大小 | 4K 左右                                                      | 5M 或者更大             | 5M 或者更大                  |
| 与服务器通信 | 每次都会携带在 HTTP 头中                                     | 不参与和服务器通信      | 不参与和服务器通信           |
| 易用性       | 需要自己封装 setCookie，getCookie                            | 可以直接使用原生接口    | 可以直接使用原生接口         |

### cookies

::: tip cookies

cookies 就是浏览器存储在用户电脑上的一小段文本文件，cookie 是纯文本格式，不包含
任何可执行代码，通常用作保留用户的登录状态。

:::

cookie 工作流程如下：

1. 浏览器发送请求给服务器；
2. 服务器设置 cookie 的值；
3. 浏览器中保存了 cookie 的值。

::: details 优缺点

**优点：**

1. 数据持久性。
2. 不需要任何服务器资源，因为 cookie 是存储在客户端并发送给服务器读取。
3. 可配置到期规则，控制 cookie 的生命周期，使之不会永远有校，偷盗者可能拿到的是
   一个过期的 cookie。
4. 简单性，基于文件的轻量结构。

**缺点：**

1. 由于 cookie 的实现机制，一旦服务器向客户端发送了设置 cookie 的意图，除非
   cookie 过期，否则客户端每次请求都会发送这些 cookie 到服务器端，一旦设置的
   cookie 过多，将会导致报头较大。大多数的 cookie 并不需要每次都用上，因为这会造
   成带宽的部分浪费。
2. cookie 只能保存 4K 左右的数据量，且大多数浏览器只允许每个站点保存 20 个
   Cookie。

:::

### sessionStorage

::: tip sessionStorage

由于 cookie 在使用的时候需要后端去设置缓存的值，在使用过程中增加前后端沟通成本，
且储存的文件过小（一般为 4kb）。而 sessionStorage 完美的解决了 cookie 的缺点。

:::

::: details 优缺点

**优点：**

1. 可以保存大量数据，存储大小一般为 5M。
2. 不会随 http 请求一起发送。
3. 不同窗口下数据存储相互独立，互不干扰。

**缺点：**

1. 不能存储复杂数据类型（复杂数据类型需要使用 JSON.stringify 进行处理）。
2. 关闭网页后缓存信息失效，是一种短存储。

:::

### localStorage

::: tip localStorage

和 sessionStorage 很相似，不同的是 localStorage 将数据保存在客户端本地的硬件设备
（通常指硬盘，也可以是其他硬件设备）中，辑视浏览器被关闭了，该数据仍然存在，下次
打开浏览器访问网站时仍然可以继续使用。

:::

---
