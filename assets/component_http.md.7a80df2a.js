import{_ as s,c as o,o as a,a as t}from"./app.331b49cb.js";const n="/h-web/http/method.png",e="/h-web/http/2xx.png",l="/h-web/http/3xx.png",i="/h-web/http/4xx.png",r="/h-web/http/5xx.png",b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"HTTP 请求方法","slug":"http-请求方法","link":"#http-请求方法","children":[]},{"level":2,"title":"HTTP 状态码","slug":"http-状态码","link":"#http-状态码","children":[]},{"level":2,"title":"浏览器跨域","slug":"浏览器跨域","link":"#浏览器跨域","children":[{"level":3,"title":"如何解决跨域问题？","slug":"如何解决跨域问题","link":"#如何解决跨域问题","children":[]}]},{"level":2,"title":"cookies、sessionStorage、localStorage 的区别","slug":"cookies、sessionstorage、localstorage-的区别","link":"#cookies、sessionstorage、localstorage-的区别","children":[{"level":3,"title":"cookies","slug":"cookies","link":"#cookies","children":[]},{"level":3,"title":"sessionStorage","slug":"sessionstorage","link":"#sessionstorage","children":[]},{"level":3,"title":"localStorage","slug":"localstorage","link":"#localstorage","children":[]}]}],"relativePath":"component/http.md"}'),p={name:"component/http.md"},c=t('<h2 id="http-请求方法" tabindex="-1">HTTP 请求方法 <a class="header-anchor" href="#http-请求方法" aria-hidden="true">#</a></h2><details class="details custom-block"><summary>点击查看</summary><p><img src="'+n+'" alt="请求方法"></p></details><hr><h2 id="http-状态码" tabindex="-1">HTTP 状态码 <a class="header-anchor" href="#http-状态码" aria-hidden="true">#</a></h2><ul><li><p><strong>1XX 信息</strong></p><p>服务器接受到请求，需要请求者继续操作。（实际开发很少遇到）</p></li><li><p><strong>2XX 成功</strong></p><p><code>200</code> 请求成功。一般用于 GET 、 POST 请求。</p><p><code>201</code> 成功请求并创建新的资源。一般用于 GET 、 POST 请求。</p><p><code>204</code> 与 200 基本相同，但响应头后没有 body 数据。</p><p><code>206</code> 是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。</p><details class="details custom-block"><summary>查看详解</summary><p><img src="'+e+'" alt="2xx"></p></details></li><li><p><strong>3XX 重定向</strong></p><p><code>301</code> 永久重定向。</p><p><code>302</code> 临时重定向。</p><p><code>304</code> 重定向到已缓存的文件。</p><details class="details custom-block"><summary>查看详解</summary><p><img src="'+l+'" alt="3xx"></p></details></li><li><p><strong>4XX 客户端错误</strong></p><p><code>400</code> 请求报文有错误，但具体是数据格式错误、缺少请求头还 是 URI 超长它没有明确说，只是一个笼统的错 误。</p><p><code>401</code> 当前请求需要用户验证。</p><p><code>403</code> 服务器禁止访问资源。</p><p><code>404</code> 资源在本服务器上未找到，所以无法提供给客户端。</p><p><code>408</code> 请求超时。</p><details class="details custom-block"><summary>查看详解</summary><p><img src="'+i+'" alt="4xx"></p></details></li><li><p><strong>5XX 服务器错误</strong></p><p><code>500</code> 服务器内部错误。</p><p><code>501</code> 服务器不支持该请求方法。</p><p><code>502</code> 通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错 误.</p><p><code>503</code> 服务器繁忙。</p><details class="details custom-block"><summary>查看详解</summary><p><img src="'+r+`" alt="5xx"></p></details></li></ul><hr><h2 id="浏览器跨域" tabindex="-1">浏览器跨域 <a class="header-anchor" href="#浏览器跨域" aria-hidden="true">#</a></h2><p>存在跨域是为了保证用户的隐私和数据安全，跨域问题是因为浏览器的同源策略，如果不同源即跨域。跨域本质上 是后端解决，但是在开发环境下可以配置反向代理来解决跨域，对于那些第三方的接口，可以使用 jsonp 的形式 解决跨域。</p><p><strong>同源策略：</strong> 浏览器不能去请求<strong>协议</strong>、<strong>域名</strong>、<strong>端口</strong>任何一个不相同的服务器资源。比如：</p><blockquote><ol><li>无法读取非同源网页的 Cookie、LocalStorage、IndexedDB</li><li>无法接触非同源网页的 DOM</li><li>无法向非同源地址发送 Ajax 请求（可以发送，但响应数据会被浏览器的同源策略拦截）</li></ol></blockquote><h3 id="如何解决跨域问题" tabindex="-1">如何解决跨域问题？ <a class="header-anchor" href="#如何解决跨域问题" aria-hidden="true">#</a></h3><ol><li><p><strong>反向代理</strong></p><div class="tip custom-block"><p class="custom-block-title">反向代理</p><p>把目标服务器的请求代理到自己的服务器中，这样就实现了在自己的服务器中去请求自己的接口资源，自然就 不存在跨域问题了。</p><p>在生产环境中也可以配置 nginx 的反向代理来解决跨域问题。</p></div><details class="details custom-block"><summary>查看代码</summary><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-comment);">// vue.config.js</span></span>
<span class="line"><span style="color:var(--shiki-token-constant);">module</span><span style="color:var(--shiki-color-text);">.</span><span style="color:var(--shiki-token-constant);">exports</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  devServer</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    </span><span style="color:var(--shiki-token-comment);">// 配置反向代理</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    proxy</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">      </span><span style="color:var(--shiki-token-string-expression);">&quot;/api&quot;</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        </span><span style="color:var(--shiki-token-comment);">// 以/api开头的请求</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        target</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">&quot;https://xxx.com&quot;</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-comment);">// 以/api开头的请求，全部代理到https://xxx.com上</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        ws</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">true</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-comment);">//代理websocked</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        changeOrigin</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">true</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-comment);">//虚拟的站点需要更换origin</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        secure</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">false</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-comment);">//是否https接口</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        pathRewrite</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">          </span><span style="color:var(--shiki-token-string-expression);">&quot;^/api&quot;</span><span style="color:var(--shiki-token-keyword);">:</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">&quot;&quot;</span><span style="color:var(--shiki-token-punctuation);">,</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-comment);">//重写路径</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">        }</span><span style="color:var(--shiki-token-punctuation);">,</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">      }</span><span style="color:var(--shiki-token-punctuation);">,</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">    }</span><span style="color:var(--shiki-token-punctuation);">,</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  }</span><span style="color:var(--shiki-token-punctuation);">,</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">};</span></span>
<span class="line"></span></code></pre></div></details></li><li><p><strong>服务的响应报文包含了正确 CORS 响应头</strong></p><p>如果服务的响应报文包含了正确 CORS 响应头，那么前后的通讯就不再存在跨域问题，可以理解为在后台服务 中开启了白名单。所以本质上来讲，解决跨域问题还是需要后端处理。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-color-text);">// 该资源可以被任意外域访问</span></span>
<span class="line"><span style="color:var(--shiki-color-text);"> Access-Control-Allow-Origin: *</span></span>
<span class="line"><span style="color:var(--shiki-color-text);"></span></span>
<span class="line"><span style="color:var(--shiki-color-text);">// 服务端仅允许来自http://xxx.com的访问</span></span>
<span class="line"><span style="color:var(--shiki-color-text);"> Access-Control-Allow-Origin: http://xxx.com</span></span>
<span class="line"><span style="color:var(--shiki-color-text);"></span></span></code></pre></div></li><li><p><strong>JSONP</strong></p><blockquote><p>浏览器的同源策略对 JavaScript 脚本向不同域的服务器请求数据进行了限制，但是没有对 HTML 中 的<code>&lt;script&gt;</code>标签进行限制，我们可以基于此规则，动态创建<code>&lt;script&gt;</code>标签进行跨域资源访问。</p><p><code>&lt;script&gt;</code>标签中 src 这一属性值设置为：接口地址+处理数据的回调函数名称。</p></blockquote><details class="details custom-block"><summary>查看代码</summary><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki css-variables"><code><span class="line"><span style="color:var(--shiki-token-keyword);">var</span><span style="color:var(--shiki-color-text);"> script </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">document</span><span style="color:var(--shiki-token-function);">.createElement</span><span style="color:var(--shiki-color-text);">(</span><span style="color:var(--shiki-token-string-expression);">&quot;script&quot;</span><span style="color:var(--shiki-color-text);">);</span></span>
<span class="line"><span style="color:var(--shiki-token-constant);">script</span><span style="color:var(--shiki-color-text);">.type </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">&quot;text/javascript&quot;</span><span style="color:var(--shiki-color-text);">;</span></span>
<span class="line"><span style="color:var(--shiki-token-comment);">// 设置接口地址+数据获取成功后的回调函数（handleData）</span></span>
<span class="line"><span style="color:var(--shiki-token-constant);">script</span><span style="color:var(--shiki-color-text);">.src </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-string-expression);">&quot;http://xxx.com/api/list&amp;callback=handleData&quot;</span><span style="color:var(--shiki-color-text);">; </span><span style="color:var(--shiki-token-comment);">// 通常为后端提供的接口</span></span>
<span class="line"><span style="color:var(--shiki-token-constant);">document</span><span style="color:var(--shiki-token-function);">.</span><span style="color:var(--shiki-token-constant);">body</span><span style="color:var(--shiki-token-function);">.appendChild</span><span style="color:var(--shiki-color-text);">(script);</span></span>
<span class="line"><span style="color:var(--shiki-token-comment);">// 回调执行函数</span></span>
<span class="line"><span style="color:var(--shiki-token-keyword);">function</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-function);">handleData</span><span style="color:var(--shiki-color-text);">(res) {</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  data </span><span style="color:var(--shiki-token-keyword);">=</span><span style="color:var(--shiki-color-text);"> </span><span style="color:var(--shiki-token-constant);">JSON</span><span style="color:var(--shiki-token-function);">.stringify</span><span style="color:var(--shiki-color-text);">(res);</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">  </span><span style="color:var(--shiki-token-constant);">console</span><span style="color:var(--shiki-token-function);">.log</span><span style="color:var(--shiki-color-text);">(data);</span></span>
<span class="line"><span style="color:var(--shiki-color-text);">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>注意：因为请求数据的接口地址是写在了<code>&lt;script&gt;</code>标签中 src 这一属性值里面，那么数据请求的方式就只 能支持 GET 请求，其他请求无法实现。目前常用于解决请求第三方服务，比如解决调用百度地图 API 的跨 域问题。</p></blockquote></details></li></ol><hr><h2 id="cookies、sessionstorage、localstorage-的区别" tabindex="-1">cookies、sessionStorage、localStorage 的区别 <a class="header-anchor" href="#cookies、sessionstorage、localstorage-的区别" aria-hidden="true">#</a></h2><div class="vp-table__container"><table><thead><tr><th>特点</th><th>cookie</th><th>sessionStorage</th><th>localStorage</th></tr></thead><tbody><tr><td>数据生命周期</td><td>可以指定 maxAge 的值规定 cookie 失效时间，默认关闭浏览器失效</td><td>关闭浏览器/关闭网站失效</td><td>除非数据被清理，否则一直存在</td></tr><tr><td>存放数据大小</td><td>4K 左右</td><td>5M 或者更大</td><td>5M 或者更大</td></tr><tr><td>与服务器通信</td><td>每次都会携带在 HTTP 头中</td><td>不参与和服务器通信</td><td>不参与和服务器通信</td></tr><tr><td>易用性</td><td>需要自己封装 setCookie，getCookie</td><td>可以直接使用原生接口</td><td>可以直接使用原生接口</td></tr></tbody></table></div><h3 id="cookies" tabindex="-1">cookies <a class="header-anchor" href="#cookies" aria-hidden="true">#</a></h3><div class="tip custom-block"><p class="custom-block-title">cookies</p><p>cookies 就是浏览器存储在用户电脑上的一小段文本文件，cookie 是纯文本格式，不包含任何可执行代码，通常 用作保留用户的登录状态。</p></div><p>cookie 工作流程如下：</p><ol><li>浏览器发送请求给服务器；</li><li>服务器设置 cookie 的值；</li><li>浏览器中保存了 cookie 的值。</li></ol><details class="details custom-block"><summary>优缺点</summary><p><strong>优点：</strong></p><ol><li>数据持久性。</li><li>不需要任何服务器资源，因为 cookie 是存储在客户端并发送给服务器读取。</li><li>可配置到期规则，控制 cookie 的生命周期，使之不会永远有校，偷盗者可能拿到的是一个过期的 cookie。</li><li>简单性，基于文件的轻量结构。</li></ol><p><strong>缺点：</strong></p><ol><li>由于 cookie 的实现机制，一旦服务器向客户端发送了设置 cookie 的意图，除非 cookie 过期，否则客户端 每次请求都会发送这些 cookie 到服务器端，一旦设置的 cookie 过多，将会导致报头较大。大多数的 cookie 并不需要每次都用上，因为这会造成带宽的部分浪费。</li><li>cookie 只能保存 4K 左右的数据量，且大多数浏览器只允许每个站点保存 20 个 Cookie。</li></ol></details><h3 id="sessionstorage" tabindex="-1">sessionStorage <a class="header-anchor" href="#sessionstorage" aria-hidden="true">#</a></h3><div class="tip custom-block"><p class="custom-block-title">sessionStorage</p><p>由于 cookie 在使用的时候需要后端去设置缓存的值，在使用过程中增加前后端沟通成本，且储存的文件过小（一 般为 4kb）。而 sessionStorage 完美的解决了 cookie 的缺点。</p></div><details class="details custom-block"><summary>优缺点</summary><p><strong>优点：</strong></p><ol><li>可以保存大量数据，存储大小一般为 5M。</li><li>不会随 http 请求一起发送。</li><li>不同窗口下数据存储相互独立，互不干扰。</li></ol><p><strong>缺点：</strong></p><ol><li>不能存储复杂数据类型（复杂数据类型需要使用 JSON.stringify 进行处理）。</li><li>关闭网页后缓存信息失效，是一种短存储。</li></ol></details><h3 id="localstorage" tabindex="-1">localStorage <a class="header-anchor" href="#localstorage" aria-hidden="true">#</a></h3><div class="tip custom-block"><p class="custom-block-title">localStorage</p><p>和 sessionStorage 很相似，不同的是 localStorage 将数据保存在客户端本地的硬件设备（通常指硬盘，也可以 是其他硬件设备）中，辑视浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。</p></div><hr>`,26),k=[c];function h(d,y,v,u,g,x){return a(),o("div",null,k)}const _=s(p,[["render",h]]);export{b as __pageData,_ as default};
